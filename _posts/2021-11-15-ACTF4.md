This is a writeup about the `ACTF4` hosted by @fish at Arizona State University

Additionally, I would like to thank:
  - @redgate for offering his time and expertise during the CTF
  - @mahaloz for bringing the oppertunity to us, along with communicating with @fish to get the ok for us (myself, @redgate, and @F4_U57) to play
  - @fish for allowing us to play, and for organizing these CTF's

## Introduction
On Saturday, November 13th 2021, myself, @redgate, and @F4_U57 participated in the attack-defence style CTF under the team name **sashimi** where we got 3rd place overall. The CTF lasted for a total of 4 hours, however, teams were allowed access to their game box 30 minutes prior to the official start time. This being an advantage we could not pass up, the team decided to meet an hour prior to the games official start to discuss game mechanics and strategy. When it was 30 minutes prior to the games start, we all connected to the box and began our play.

## Game Description
The game works by having a number of teams with duplicate game boxes hosting some services, of which contain vulerabilities. It is each teams objective to capture `flags` from other teams servers, while protecting their own. To accomplish this, teams find exploits in their own services, patch it on their own machine, and exploit it on another. 

## Getting Connected and Game Setup
To get connected to the game box, each team was provided a private `ssh-key.key` along with a `ssh host` to connect to via `ssh`. Upon connection, the user is prompted with the following message:

> All services are running insider their own Docker containers. Their ports are mapped to the host, starting from 10001.
> 
> Each challenge is located at /opt/ictf/services inside its directory. You may modify the files inside to patch your services.

First thing first, @redgate advised us to make a recursive copy of the `/opt/ictf` directory to our home (`~`) directory. That way, if anything went wrong or we got super pwnd, we could recover. After this, I began taking a look at the services that we were provided with, of which there were three:

- `mommyservice` : a baby naming service
  - Service provided via a python script
- `bl4ckg0ld` : a coffee recipe service
  - Service provided via a binary
- `dungeon` : a text based adventure game
  -  Service provided via a binary

My teammate @F4_U57 began working on the `mommyservice`, I thought it would be best to split our efforts. Therefore, I began looking into `bl4ckg0ld` first, along with setting up defensive surveying on our server.

## Eyes on the stream - TCP monitoring
Before the game began, @fish was kind enough to remind everyone of the `tcpdump` command. Specifically:
```
tcpdump -i tun0 -w /tmp/<filename> -G 300 -C 100 -K -n "tcp port <port#>"
```
With this command, we are able to monitor the traffic that is comming into our server on a specific port, an invaluable tool to see what other teams are trying to do. The command, however, does hold the command line hostage until it has finished collecting. Therefore, it is recommended to either have a multiplexed terminal to have many going at once, to background the command, or to have a tmux session to handle the command.

Once enough information has been collected, we can copy the file (`/tmp/<filename>` from the aformentioned command) to our local machine to analyze. I personally used the WireShark software, as recommended by @redgate, and it proved to serve me well. 

## Ongoing Defence

Though I am not going to explicitly mention it, throughout this entire process, I was analyzing tcp dumps to monitor what other teams were doing to our services. In doing so, I had to divide my attention from doing analysis on our services, to downloading tcp dump files (using the `scp` command) to my local machine, to run through WireShark. Within WireShark, I would then look for the FLG string (since I know flags in this CTF begin with this) to see if any flags were captured from our server. If they have been, I could look at what the other team's input was and reverse engineer their exploit. **Note:** not all flag captures are done by other teams, there are bots that check for flags and service status on each teams box. Therefore, when looking at the TCP stream, we also have to check whether the input was from one of these bots that know the passwords to access the flags, or from another team exploiting.

## bl4ckg0ld
`bl4ckg0ld` is a service that allows users to write and read "recipes", it is loosly based on Starbucks. The file is served through a binary executable (ELF file) that is called `Bl4ckG0ld`. Given that it is a binary executable, to properly do analysis on it, we need to decompile it. The tool that I used and I recommend is `Ghidra`, which will decompile the file and display it in C code along side assembly.
### Analysis
For the sake of brevity, I will refrain from posting the actual decompiled code within this writeup. What is neccessary to know is that there are three effective functions:

- brew(char* a, char* b, ushort len): A function that "brews" a recipe.
- add_recipe(): A function that writes a recipe to memory
- print_recipe(): A function that prints the content of a recipe, given a password and ID

For the sake of getting flags, the `print_recipe()` is the most obvious method to exploit. Issue is, we won't be able to get the password, nor will we really know the recipe ID (flag file name), so there isn't any immediate vulnerabilities that shine in this routine. There is, however, a glaring exploit in the `add_recipe()` function. For, within the file, we have both a user input with a size that is larger than the buffer, and a call to a `new_file(char* filename, char* content)` function that does an unchecked writes bytes to a file.


*image of the add_recipe() function*

![image](https://user-images.githubusercontent.com/71113694/142078028-75875d6f-5af5-4e6a-82d6-9a44ff3c6b61.png)

Exploit is a possible buffer overflow because content[400] and password[40], while the scanf (highlighted) takes in 500 bytes for the content and 50 for the password

_image of the new_file(char* filename, char* content)_

![image](https://user-images.githubusercontent.com/71113694/142077578-7305f24a-854f-4a68-81a0-2a90429a7efe.png)

Has no checks on file overwrites, and uses write bytes "wb", which will overwrite files.

### Exploit
#### Getting Exploited
Unfortunately, though we were able to find the exploit present in the `add_recipe()` function, and the potential way to capture a flag in the `print_recipe()` function, we did not act fast enough. While I was decompiling the binary and analyzing it, I quickly took a moment to analyze another TCP dump file which I had watching the bl4ckg0ld service. After inserting the file into WireShark, I searched for the string FLG (since I knew all the flags began with this) to see if we had any compromises. Unfortunately, we had.

*image of WireShark showing that a FLG was sent from our service*

![image](https://user-images.githubusercontent.com/71113694/142069635-0525773a-1994-4a55-a8d4-605619e40155.png)

This shows that we were exploited, and we had a flag stolen. To find this, I searched for the term FLG (converted to hex) within WireShark. Of course, in practice, make sure to inspect the stream and ensure that the input was from another user exploiting the service rather than a game bot.

*image of the TCP Stream that was used to exploit our service*

![image](https://user-images.githubusercontent.com/71113694/142080272-9652e4ec-400a-48ef-9f8e-a3a3aba92aca.png)

This confirms our suspicions that the exploit (at least the most obvious one) is a buffer overflow in the `add_recipe()` function. We know that the function being used is the `add_recipe()` function because the user inputed an 'A' first. Then the massive byte dump is standard for a buffer overflow.

*image of our flags on the server after the above exploit was completed*

![image](https://user-images.githubusercontent.com/71113694/142080474-28db89e0-e713-420e-a012-3087c075ced7.png)

### Patch

## dungeon
### Analysis


### Exploit
### Mistake
